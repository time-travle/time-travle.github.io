核心组件基本上所有的消息中间件都是相同的，或许只是命名不同；

    1 Broker（消息服务器）
        消息服务器是消息中间件中，用于接收和转发消息的核心组件；

    2 Producer（消息生成者）
        负责生成消息并将消息传输到Broker

    3 Conumer（消息消费者）
        负责从Broker获取消息并消费处理

    4 Topic（消息主题）
        主题是消息传递过程中，生产者给指定生成者传递消息的标识；先由消费者订阅该主题的队列，再由消息生成者向该主题传递消息；

    5 Queue（消息队列）
        消息队列是消息存放的地方；当生产者向Broker传递消息后，消息服务器会将消息存放到指定topic的队列中等待消费者消费；

    6 Message（消息体）
        消息体，就是承载消息的主体；其中包含了所需要传递的消息内容。





ActiveMQ
    开发语言：java
    消息存储:内存、磁盘、数据库。支持少量堆积

    优点
        单机吞吐量：万级
        topic数量都吞吐量的影响：
        时效性：ms级
        可用性：高，基于主从架构实现高可用性
        消息可靠性：有较低的概率丢失数据
        功能支持：MQ领域的功能极其完备
    缺点:
        官方社区现在对ActiveMQ 5.x维护越来越少，较少在大规模吞吐的场景中使用。


RabbitMQ 
    开发语言：Erlang
    消息存储:内存、磁盘。支持少量堆积
    https://blog.csdn.net/qq_41936805/article/details/88896623

    RabbitMQ优点：
        由于erlang语言的特性，mq 性能较好，高并发；
        吞吐量到万级，MQ功能比较完备
        健壮、稳定、易用、跨平台、支持多种语言、文档齐全；
        开源提供的管理界面非常棒，用起来很好用
        社区活跃度高；
    RabbitMQ缺点：
        erlang开发，很难去看懂源码，基本职能依赖于开源社区的快速维护和修复bug，不利于做二次开发和维护。
        RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重。
        需要学习比较复杂的接口和协议，学习和维护成本较高。

RocketMQ
    开发语言：java
    消息存储:磁盘。支持大量堆积。

    rocketMQ优点：

        单机吞吐量：十万级
        可用性：非常高，分布式架构
        消息可靠性：经过参数优化配置，消息可以做到0丢失
        功能支持：MQ功能较为完善，还是分布式的，扩展性好
        支持10亿级别的消息堆积，不会因为堆积导致性能下降
        源码是java，我们可以自己阅读源码，定制自己公司的MQ，可以掌控
    RocketMQ缺点：

        支持的客户端语言不多，目前是java及c++，其中c++不成熟；
        社区活跃度一般
        没有在 mq 核心中去实现JMS等接口，有些系统要迁移需要修改大量代码

kafka：
    开发语言：Scala  
    消息存储:内存、磁盘、数据库。支持大量堆积。

    优点
        性能卓越，单机写入TPS约在百万条/秒，最大的优点，就是吞吐量高。
        时效性：ms级
        可用性：非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用
        消费者采用Pull方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;
        有优秀的第三方Kafka Web管理界面Kafka-Manager；
        在日志领域比较成熟，被多家公司和多个开源项目使用；
        功能支持：功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用
    缺点：
        Kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长
        使用短轮询方式，实时性取决于轮询间隔时间；
        消费失败不支持重试；
        支持消息顺序，但是一台代理宕机后，就会产生消息乱序；
        社区更新较慢；



RPC 框架（RPC是指远程过程调用 Remote Procedure Call）的重要组成：

    客户端(Client)：服务调用方。
    客户端存根(Client Stub)：存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端。
    服务端存根(Server Stub)：接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理。
    服务端(Server)：服务的真正提供者。
    Network Service：底层传输，可以是 TCP 或 HTTP。







































