遇到的不一样的问题

1、npm和cnpm的区别：
	npm节点包管理器，用与nodejs中节点插件管理，其中包括插件的安装和卸载以及管理依赖的功能呢
	但是有npm这个命令会比较慢 这个默认服务器不是在我们国内，而使用 cnpm这个就会快些 这个是在国内的一个镜像

2、computed VS methods  https://www.cnblogs.com/goloving/p/8964602.html
	我们可以通过在表达式中调用方法来达到同样的效果，我们可以将同一函数定义为一个方法而不是一个计算属性。
	两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。
	
	计算属性只有在它的相关依赖发生改变时才会重新求值。
	计算属性只有在它的相关依赖发生改变时才会重新求值。
	
	这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 
	计算属性会立即返回之前的计算结果，而不必再次执行函数。（缓存的效果）这也同样意味着下面的计算属性将不再更新，
	因为 Date.now() 不是响应式依赖：

	computed: {
	// 里面的是一些方法供直接调用 为一个属性直接绑定方法
	  now: function () {
		return Date.now()
	  }
	}
　　相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。
　　我们为什么需要缓存？假设我们有一个性能开销比较大的的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。
	然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！
	如果你不希望有缓存，请用方法来替代。
	
3、computed VS watch
　　Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，
	你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。
	
	虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。
	这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。
	当需要在数据变化时执行异步或开销较大的操作时，watch这个方式是最有用的。

4、计算属性禁用箭头函数
　　注意，不应该使用箭头函数来定义计算属性函数 (例如 aDouble: () => this.a * 2)。
	理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.a 将是 undefined。

　　当然有很多this需要指向vue实例的时候，都需要慎用箭头函数	

5、vue的实现流程
	三要素: 双向绑定、模板解析、渲染

	第一步：解析模板成render函数

		with的引用
		模板中所有的信息都要被render函数包含
		模板中用到的data属性都变成js变量
		v-modle、v-for……变成js
		返回vnode
	第二步： 响应式开始监听

		通过object.defineProperty监听到data中属性的get和set方法
		将data中的属性代理带vm上
	第三步： 首次渲染，显示页面，绑定依赖

		首次渲染使用uodateComponent()函数
		vm.patch（$el, vnode）
		patch将vnode转换成dom，完成首次渲染
	第四步：data变化，触发rerender

		命中set的监听
		set 中执行updateComponent
		uodate重新执行render()
		vdom和preVdom比较
		渲染到dom中