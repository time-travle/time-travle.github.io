1、select 查询


2、order by 排序
	按多个列排序行示例
		ORDER BY first_name, last_name DESC; --- 按first_name进行按升序排序，并按降序对last_name列进行排序
	
	按列位置排序行示例
		SELECT name, credit_limit,address FROM customers ORDER BY 2 DESC, 1;
		相当于
		SELECT name, credit_limit,address FROM customers ORDER BY credit_limit DESC, name;


3、distinct 去重
	DISTINCT语句的语法如下：SELECT DISTINCT clo* from 
	单列 SELECT DISTINCT clo from 
	多列 SELECT DISTINCT clo1, clo1 from 


4、Fetch子句


5、事务
	事务提交 commit
		COMMIT [ WORK ] [ COMMENT clause ] [ WRITE clause ] [ FORCE clause ];
		参数
			WORK：可选的。它被Oracle添加为符合SQL标准。使用或不使用WORK参数来执行COMMIT将产生相同的结果。
			COMMENT clause：可选的。 它用于指定与当前事务关联的注释。 该注释最多可以包含在单引号中的255个字节的文本中。 如果出现问题，它将与事务ID一起存储在名为DBA_2PC_PENDING的系统视图中。
			WRITE clause：可选的。 它用于指定将已提交事务的重做信息写入重做日志的优先级。 用这个子句，有两个参数可以指定：WAIT 或 NOWAIT (如果省略，WAIT是默认值)IMMEDIATE或BATCH(IMMEDIATE是省略时的默认值)
			FORCE clause：可选的。 它用于强制提交可能已损坏或有疑问的事务。 有了这个子句，可以用3种方式指定FORCE：FORCE'string'，[integer]或FORCE CORRUPT_XID'string'或FORCE CORRUPT_XID_ALL
		注意
			必须拥有DBA权限才能访问系统视图 - DBA_2PC_PENDING和V$CORRUPT_XID_LIST。
			必须拥有DBA权限才能指定COMMIT语句的某些功能。
	事务回滚 rollback
		ROLLBACK [ WORK ] [ TO [SAVEPOINT] savepoint_name  | FORCE 'string' ];
		参数
			WORK：可选的。 它被Oracle添加为符合SQL标准。 使用或不使用WORK参数来发出ROLLBACK会导致相同的结果。
			TO SAVEPOINT savepoint_name：可选的。 ROLLBACK语句撤消当前会话的所有更改，直到由savepoint_name指定的保存点。 如果省略该子句，则所有更改都将被撤消。
			FORCE ‘string’：可选的。它用于强制回滚可能已损坏或有问题的事务。 使用此子句，可以将单引号中的事务ID指定为字符串。 可以在系统视图中找到名为DBA_2PC_PENDING的事务标识。
			必须拥有DBA权限才能访问系统视图：DBA_2PC_PENDING和V$CORRUPT_XID_LIST。
			您无法将有问题的事务回滚到保存点。
	事务设置 SET TRANSACTION
		SET TRANSACTION [ READ ONLY | READ WRITE ]
                [ ISOLATION LEVEL [ SERIALIZE | READ COMMITED ]
                [ USE ROLLBACK SEGMENT 'segment_name' ]
                [ NAME 'transaction_name' ];
		参考
		   ● READ ONLY：可以将事务设置为只读事务。
		   ● READ WRITE：可以将事务设置为读/写事务。
		   ● ISOLATION LEVEL： 如果指定，它有两个选项：
				1.ISOLATION LEVEL SERIALIZE：如果事务尝试更新由另一个事务更新并未提交的资源，则事务将失败。
				2.ISOLATION LEVEL READ COMMITTED：如果事务需要另一个事务持有的行锁，则事务将等待，直到行锁被释放。
		   ● USE ROLLBACK SEGMENT：可选的。 如果指定，它将事务分配给由'segment_name'标识的回退段，该段是用引号括起来的段名称。
		   ● NAME：为'transaction_name'标识的事务分配一个名称，该事务用引号括起来。		
				
	锁表 lock table
		LOCK TABLE tables IN lock_mode MODE [ WAIT [, integer] | NOWAIT ];
		参数
			tables：用逗号分隔的表格列表。
			WAIT：它指定数据库将等待(达到指定整数的特定秒数)以获取DML锁定。
			NOWAIT：它指定数据库不应该等待释放锁。
			lock_mode ：它是以下值之一：
				ROW SHARE	允许同时访问表，但阻止用户锁定整个表以进行独占访问。
				ROW EXCLUSIVE	允许对表进行并发访问，但阻止用户以独占访问方式锁定整个表并以共享方式锁定表。
				SHARE UPDATE	允许同时访问表，但阻止用户锁定整个表以进行独占访问。
				SHARE	允许并发查询，但用户无法更新锁定的表。
				SHARE ROW EXCLUSIVE	用户可以查看表中的记录，但是无法更新表或锁定SHARE表中的表。
				EXCLUSIVE	允许查询锁定的表格，但不能进行其他活动。


6、约束
	唯一主键
	联合主键
	外键
	插入校验


7、内置函数
	Ascii()函数
		ASCII( single_character ) 
		参数
			single_character：指定的字符来检索NUMBER代码。 如果输入多个字符，则ASCII函数将返回第一个字符的值，
			并忽略第一个字符后的所有字符。
		返回值
			ASCII函数返回一个数值。

	Asciistr()函数
		ASCIISTR( string )
		参数
			string：任何字符集中的字符串，希望将其转换为数据库字符集中的ASCII字符串。
		返回值
			返回一个字符串值

	Chr()函数
		CHR( number_code )
		参数
			number_code：用于检索对应字符的NUMBER代码。
		返回值
			返回一个字符串值

	Compose()函数
		COMPOSE( string )
		参数	
			string：用于创建Unicode字符串的输入值。 它可以是char，varchar2，nchar，nvarchar2，clob或nclob。
		返回值
			返回一个字符串值。

	CONCAT()函数
		CONCAT( string1, string2 )
		参数
			string1：第一个要连接的字符串。
			string2：第二个要连接的字符串。
		返回值
			CONCAT函数返回string1连接string2后的一个字符串值。

	||运算符语法
		string1 || string2 [ || string_n ]
		参数
			string1： 第一个要连接的字符串。
			string2：第二个要连接的字符串。
			string_n：可选项，第n个要连接的字符串。
		返回值
			返回连接后的一个字符串值。
		
	Convert()函数
		CONVERT( string1, char_set_to [, char_set_from] )
		参数
			string1：要转换的字符串。
			char_set_to：要转换为的字符集。
			char_set_from：可选的，要从中转换的字符集。
		返回值
			CONVERT函数返回特定字符集中的字符串值。

	Initcap()函数
		INITCAP( string1 )
		参数
			string1 ：字符串参数，其中每个单词中的第一个字符将转换为大写字母，其余所有字符转换为小写字母。
		返回值
			返回一个字符串值。

	LOWER
		语法：LOWER(string)
		功能：所以字母小写

	UPPER
		语法: UPPER（string）
		功能: 所有字母大写.
		（不是字母的字符不变.如果string是CHAR数据类型的,那么结果也是CHAR类型的.如果string是VARCHAR2类型的,那么结果也是VARCHAR2类型的）.


在oracle中，数据表别名不能加as，如：
	select a.appname from appinfo a;-- 正确 
	select a.appname from appinfo as a;-- 错误 
	
	
每张表最多可建立12 种类型的触发器
	BEFORE INSERT
	BEFORE INSERT FOR EACH ROW
	AFTER INSERT
	AFTER INSERT FOR EACH ROW

	BEFORE UPDATE
	BEFORE UPDATE FOR EACH ROW
	AFTER UPDATE
	AFTER UPDATE FOR EACH ROW

	BEFORE DELETE
	BEFORE DELETE FOR EACH ROW
	AFTER DELETE
	AFTER DELETE FOR EACH ROW
