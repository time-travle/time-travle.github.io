<p>
    <a href="#" onclick="refreshContent('redis')">返回目录</a>
</p>

---

## 集群部署

### 集群模式：主从复制

    Redis的主从复制解决了数据的备份，以及读写分离。在主服务器出现损坏的时候从服务器依然可以保证数据的安全

    主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器，主从是哨兵和集群模式能够实施的基础。前者称为主节点(master)，后者称为从节点(slave),数据的复制是单向的，只能由主节点到从节点。
    默认情况下，每台Redis服务器都是主节点；且一个主节点可以有零个或多个从节点(0+个从节点)，但一个从节点只能有一个主节点。一般主节点负责接收写请求，从节点负责接收读请求，从而实现读写分离。
    主从一般部署在不同机器上，复制时存在网络延时问题，使用参数repl-disable-tcp-nodelay选择是否关闭TCP_NODELAY,默认为关闭：
    关闭：无论数据大小都会及时同步到从节点，占带宽，适用于主从网络好的场景；
    开启：主节点每隔指定时间合并数据为TCP包节省带宽，默认为40毫秒同步一次，适用于网络环境复杂或带宽紧张，如跨机房；

![avatar](../blog/redis/imag/redis1.png)或者
![avatar](../blog/redis/imag/redis2.png)

    作用:
        数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。
        故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。
        负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务，分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。
        读写分离：主库写、从库读，读写分离不仅可以提高服务器的负载能力，同时可根据需求的变化，改变从库的数量；
        高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础
    
    开启主从配置
        配置主从可以在命令行或配置文件中配置，上面提到主节点负责写，从节点负责读，因此推荐开启从服务器的只读配置，否则的话在从节点的写操作不会同步到主节点会导致数据不一致：

        命令行模式
            在从服务器命令行中执行下面的命令即可成为该主服务器的从节点：

                #在从服务器执行下面的命令成为或取消成为某节点的从节点#slaveof  主服务器的IP  端口号slaveof  host port
                #取消成为任何服务器的从服务器slaveof no one
                #从服务器只读(推荐配置)config set slave-read-only yes
                #查看主从信息info replication
                #配置主节点ACL账号密码(Redis6开启ACL的情况)config set masteruser usernameconfig set masterauth password
            
            slaveof 命令是异步的，不会阻塞。
            同时，从服务器现有的数据会先被清空，然后才会同步主服务器的数据。
        
        配置文件
            在从服务器配置文件中添加下面的配置然后重启从服务器即可：
        
                #在从节点配置文件中新增下面两个配置即可指定成为某个主节点的从节点#slaveof 主节点地址 主节点端口slaveof  host port
                #从服务器只读(推荐配置)slave-read-only yes

#### 一主一从

    最基础的主从复制模型，主节点负责处理写请求，从节点负责处理读请求，主节点使用RDB持久化模式，从节点使用AOF持久化模式：

![avatar](../blog/redis/imag/one2one.png)

#### 一主多从

    一个主节点可以有多个从节点，但每个从节点只能有一个主节点。一主多从适用于写少读多的场景，多个从节点可以分担读请求负载，提升并发：

![avatar](../blog/redis/imag/one2many.png)

#### 树状主从

    上面的一主多从可以实现读请求的负载均衡，但当从节点数量多的时候，主节点的同步压力也是线性提升的，因此可以使用树状主从来分担主节点的同步压力：

![avatar](../blog/redis/imag/treecluster.png)

#### 复制原理

    主从复制过程大体可以分为3个阶段：连接建立阶段（即准备阶段）、数据同步阶段、命令传播阶段。
    
    在从节点执行 slaveof 命令后，复制过程便开始按下面的流程运作：
    
    保存主节点信息：配置slaveof之后会在从节点保存主节点的信息。
    主从建立socket连接：定时发现主节点以及尝试建立连接。
    发送ping命令：从节点定时发送ping给主节点，主节点返回PONG。若主节点没有返回PONG或因阻塞无法响应导致超时，则主从断开，在下次定时任务时会从新ping主节点。
    权限验证：若主节点开启了ACL或配置了requirepass参数，则从节点需要配置masteruser和masterauth参数才能保证主从正常连接。
    同步数据集：首次连接，全量同步。
    命令持续复制：全量同步完成后，保持增量同步。

#### 复制过程

Redis 的从服务器在向主服务器发起同步时，一般会使用 SYNC 或 PSYNC 命令。

初次同步

    当从服务器收到 SLAVEOF 命令后，会向其主服务器执行同步操作，进入主从复制流程。
    
    从服务器向主服务器发起SYNC 或 PSYNC 命令
    主服务器执行 BGSAVE命令，生成 RDB 文件，并使用缓存区记录从现在开始的所有写命令
    RDB 文件生成完成后，主服务器会将其发送给从服务器
    从服务器载入 RDB 文件，将自己的数据库状态同步更新为主服务器执行 BGSAVE命令时的状态。
    主服务器将缓冲区的所有写命令发送给从服务器，从服务将执行这些写命令，数据库状态同步为主服务器最新状态。

![avatar](../blog/redis/imag/redis3.png)
SYNC 与 PSYNC 的区别

    当主从同步完成后，如果此时从服务器宕机了一段时间，重新上线后势必要重新同步一下主服务器，SYNC与 PSYNC命令的区别就在于断线后重复制阶段处理的方式不同。
    
    SYNC：    从服务器重新向主服务器发起 SYNC命令，主服务器将所有数据再次重新生成 RDB 快照发给从服务器开始同步
    
    PSYNC：    从服务器重新向主服务器发起 PSYNC命令。主服务器根据双方数据的偏差量判断是否是需要完整重同步还是仅将断线期间执行过的写命令发给从服务器。
    
    明显可以发先 PSYNC 相比 SYNC 效率好很多，要知道同步所有数据是一个非常费资源(磁盘 IO,网络)的操作，而如果只是因为短暂网络不稳定就同步所有资源是非常不值的。因此 Redis 在 2.8 版本后都开始使用 PSYNC 进行复制

PSYNC 如何实现部分重同步?

    实现部分重同步主要靠三部分
    
    1. 记录复制偏移量
    
        主服务器与从服务器都会维护一个复制偏移量。
        
        当主服务器向从服务器发送 N 个字节的数据后，会将自己的复制偏移量 +N。
        当从服务器收到主服务器 N 个字节大小数据后，也会将自己的复制偏移量 +N。
        当主从双方数据是同步时，这个偏移量是相等的。而一旦有个从服务器断线一段时间而少收到了部分数据。那么此时主从双方的服务器偏移量是不相等的，而他们的差值就是少传输的字节数量。如果少传输的数据量不是很大，没有超过主服务器的复制积压缓冲区大小，那么将会直接将缓冲区内容发送给从服务器避免完全重同步。反之还是需要完全重同步的。
        
    2. 复制积压缓冲区
    
        复制积压缓冲区是由主服务器维护的一个先进先出的字节队列，默认大小是 1mb。每当向从服务器发送写命令时，都会将这些数据存入这个队列。每个字节都会记录自己的复制偏移量。从服务器在重连时会将自己的复制偏移量发送给主服务器，如果该复制偏移量之后的数据存在于复制积压缓冲区中，则仅需要将之后的数据发送给从服务器即可。
    
    3. 记录服务器 ID
    
        当执行主从同步时，主服务器会将自己的服务器 ID (一般是自动生成的 UUID ) 发送给从服务器。从服务器在断线恢复后会判断该 ID 是否为当前连接的主服务器。如果是同一个 ID 则代表主服务器没变尝试部分重同步。如果不是同一个 ID 代表主服务有变动，则会与主服务器完全重同步。

![avatar](../blog/redis/imag/redis4.png)

#### 主从复制的优缺点

    优点：        
        master能自动将数据同步到slave，可以进行读写分离，分担master的读压力
        master、slave之间的同步是以非阻塞的方式进行的，同步期间，客户端仍然可以提交查询或更新请求
    缺点：        
        不具备自动容错与恢复功能，master或slave的宕机都可能导致客户端请求失败，需要等待机器重启或手动切换客户端IP才能恢复
        master宕机，如果宕机前数据没有同步完，则切换IP后会存在数据不一致的问题
        难以支持在线扩容，Redis的容量受限于单机配置

### 集群模式：哨兵

    Redis 主从模式虽然能做到很好的数据备份，但是他并不是高可用的。一旦主服务器点宕机后，只能通过人工去切换主服务器。
    因此 Redis 的哨兵模式也就是为了解决主从模式的高可用方案。
    
    哨兵模式引入了一个 Sentinel 系统去监视主服务器及其所属的所有从服务器。
    一旦发现有主服务器宕机后，会自动选举其中的一个从服务器升级为新主服务器以达到故障转义的目的。

    哨兵（sentinel），用于对主从结构中的每一台服务器进行监控，当主节点出现故障后通过投票机制来挑选新的主节点，并且将所有的从节点连接到新的主节点上。

    前面的主从是最基础的提升Redis服务器稳定性的一种实现方式，但我们可以看到master节点仍然是一台，若主节点宕机，所有从服务器都不会有新的数据进来，如何让主节点也实现高可用，当主节点宕机的时候自动从从节点中选举一台节点提升为主节点就是哨兵实现的功能。

#### 作用

        监控：监控主从节点运行情况。
        通知：当监控节点出现故障，哨兵之间进行通讯。
        自动故障转移：当监控到主节点宕机后，断开与宕机主节点连接的所有从节点，然后在从节点中选取一个作为主节点，将其他的从节点连接到这个最新的主节点。最后通知客户端最新的服务器地址。
    
    哨兵也是一台redis服务器，只是不对外提供任何服务，redis的bin目录下的redis-sentinel其实就是redis-server的软连接。
    哨兵节点最少三台且必须为单数。这个与其他分布式框架如zookeeper类似，如果是双数，在选举的时候就会出现平票的情况，所以必须是三台及以上的单数。

#### 原理

        哨兵之间会有通讯，哨兵和主从节点之间也有监控，基于这些信息同步和状态监控实现Redis的故障转移：
        
        哨兵和哨兵之间以及哨兵和Redis主从节点之间每隔一秒发送ping监控它们的健康状态；
        哨兵向Redis主从节点每隔10秒发送一次info保存节点信息；
        哨兵向Redis主节点每隔2秒发送一次hello，直到哨兵报出sdown，代表主节点失联，然后通知其余哨兵尝试连接该主节点；

#### Redis主节点下线的情况分为主观下线和客观下线：

        主观下线(sdown)：单独一个哨兵发现master故障了。
        客观下线(odown)：半数哨兵都认为master节点故障就会触发故障转移。
        
        哨兵Leader选举：
    
        一般情况下当哨兵发现主节点sdown之后 该哨兵节点会成为领导者负责处理主从节点的切换工作：
            哨兵A发现Redis主节点失联；
            哨兵A报出sdown，并通知其他哨兵，发送指令sentinel is-master-down-by-address-port给其余哨兵节点；
            其余哨兵接收到哨兵A的指令后尝试连接Redis主节点，发现主节点确实失联；
            哨兵返回信息给哨兵A，当超过半数的哨兵认为主节点下线后，状态会变成odown；
            最先发现主节点下线的哨兵A会成为哨兵领导者负责这次的主从节点的切换工作；

![avatar](../blog/redis/imag/sentinel.png)

        哨兵的选举机制是以各哨兵节点接收到发送sentinel is-master-down-by-address-port指令的哨兵id 投票，票数最高的哨兵id会成为本次故障转移工作的哨兵Leader；

#### 故障转移：

    当哨兵发现主节点下线之后经过上面的哨兵选举机制，选举出本次故障转移工作的哨兵节点完成本次主从节点切换的工作：
        哨兵Leader 根据一定规则从各个从节点中选择出一个节点升级为主节点；
        其余从节点修改对应的主节点为新的主节点；
        当原主节点恢复启动的时候，变为新的主节点的从节点

    哨兵Leader选择新的主节点遵循下面几个规则：        
        健康度：从节点响应时间快；            
        完整性：从节点消费主节点的offset偏移量尽可能的高 ()；            
        稳定性：若仍有多个从节点，则根据从节点的创建时间选择最有资历的节点升级为主节点；
        
    在哨兵模式下主从节点总是会变更。

#### 哨兵模式的优缺点

    优点：    
        哨兵模式基于主从复制模式，所以主从复制模式有的优点，哨兵模式也有
        哨兵模式下，master挂掉可以自动进行切换，系统可用性更高
    缺点：    
        同样也继承了主从模式难以在线扩容的缺点，Redis的容量受限于单机配置
        需要额外的资源来启动sentinel进程，实现相对复杂一点，同时slave节点作为备份节点不提供服务

### 集群模式：Cluster模式（插槽）

Redis 哨兵模式实现了高可用，读写分离，但是其主节点仍然只有一个，即写入操作都是在主节点中，这也成为了性能的瓶颈。

因此 Redis 在 3.0 后加入了 Cluster 模式，它采用去无心节点方式实现，集群将会通过分片方式保存数据库中的键值对

Redis集群(Redis Cluster)是从 Redis 3.0 开始引入的分布式存储方案。集群由多个节点(Node)组成，Redis 的数据分布在这些节点中。

集群中的节点分为主节点和从节点，只有主节点负责读写请求和集群信息的维护，从节点只进行主节点数据和状态信息的复制。

Redis集群采用去中心化的思想，没有中心节点的说法，对于客户端来说，整个集群可以看成一个整体，可以连接任意一个节点进行操作，就像操作单一Redis实例一样，不需要任何代理中间件，当客户端操作的key没有分配到该node上时，Redis会返回转向指令，指向正确的node。

Redis也内置了高可用机制，支持N个master节点，每个master节点都可以挂载多个slave节点，当master节点挂掉时，集群会提升它的某个slave节点作为新的master节点。

Redis集群可以看成多个主从架构组合起来的，每一个主从架构可以看成一个节点（其中，只有master节点具有处理请求的能力，slave节点主要是用于节点的高可用）

#### 作用

    Redis集群的作用有下面几点：    
        数据分区：突破单机的存储限制，将数据分散到多个不同的节点存储；
        负载均衡：每个主节点都可以处理读写请求，提高了并发能力；
        高可用：集群有着和哨兵模式类似的故障转移能力，提升集群的稳定性；

#### Redis 集群提供了以下两个好处：

    将数据自动切分（split）到多个节点的能力。
    当集群中的一部分节点失效或者无法进行通讯时， 仍然可以继续处理命令请求的能力。

#### 原理

数据分区规则

    衡量数据分区方法的标准有两个重要因素：1) 是否均匀分区; 2)增减节点对数据分布的影响;
    
    由于哈希算法具有随机性，可以保证数据均匀分布，因此Redis集群采用哈希分区的方式对数据进行分区，哈希分区就是对数据的特征值进行哈希，然后根据哈希值决定数据放在哪里。

常见的哈希分区有：

    哈希取余：    
        计算key的hash值，对节点数量做取余计算，根据结果将数据映射到对应节点；但当节点增减时，系统中所有数据都需要重新计算映射关系，引发大量数据迁移；
    
    一致性哈希：    
        将hash值区间抽象为一个环形，节点均匀分布在该环形之上，然后根据数据的key计算hash值，在该hash值所在的圆环上的位置延顺时针行走找到的第一个节点的位置，该数据就放在该节点之上。相比于哈希取余，一致性哈希分区将增减节点的影响限制为相邻节点。
    
    带虚拟节点的一致性哈希 (Redis集群)：
        Redis采用的方案，在一致性哈希基础之上，引入虚拟节点的概念，虚拟节点被称为槽(slot)。Redis集群中，槽的数量为16384。        
        槽介于数据和节点之间，将节点划分为一定数量的槽，每个槽包含哈希值一定范围内的数据。由原来的hash-->node 变为 hash-->slot-->node。        
        当增删节点时，该节点所有拥有的槽会被重新分配给其他节点，可以避免在一致性哈希分区中由于某个节点的增删造成数据的严重分布不均。

![avatar](../blog/redis/imag/cluster.png)

哈希槽算法

    Redis集群通过分布式存储的方式解决了单节点的海量数据存储的问题，对于分布式存储，需要考虑的重点就是如何将数据进行拆分到不同的Redis服务器上。
    常见的分区算法有hash算法、一致性hash算法

    普通hash算法：将key使用hash算法计算之后，按照节点数量来取余，即hash(key)%N。优点就是比较简单，但是扩容或者摘除节点时需要重新根据映射关系计算，会导致数据重新迁移。
    
    一致性hash算法：为每一个节点分配一个token，构成一个哈希环；查找时先根据key计算hash值，然后顺时针找到第一个大于等于该哈希值的token节点。优点是在加入和删除节点时只影响相邻的两个节点，缺点是加减节点会造成部分数据无法命中，所以一般用于缓存，而且用于节点量大的情况下，扩容一般增加一倍节点保障数据负载均衡。


    Redis集群采用的算法是哈希槽分区算法。
        Redis集群中有16384个哈希槽（槽的范围是 0 -16383，哈希槽），将不同的哈希槽分布在不同的Redis节点上面进行管理，也就是说每个Redis节点只负责一部分的哈希槽。
        在对数据进行操作的时候，集群会对使用CRC16算法对key进行计算并对16384取模（slot = CRC16(key)%16383），得到的结果就是 Key-Value 所放入的槽，通过这个值，去找到对应的槽所对应的Redis节点，然后直接到这个对应的节点上进行存取操作

    使用哈希槽的好处就在于可以方便的添加或者移除节点，并且无论是添加删除或者修改某一个节点，都不会造成集群不可用的状态。
    当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了；当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了；
    哈希槽数据分区算法具有以下几种特点：
        
        解耦数据和节点之间的关系，简化了扩容和收缩难度；
        节点自身维护槽的映射关系，不需要客户端代理服务维护槽分区元数据
        支持节点、槽、键之间的映射查询，用于数据路由，在线伸缩等场景

#### 通信机制

    在上面的哨兵方案中，节点被分为数据节点和哨兵节点，哨兵节点也是redis服务，但只作为选举监控使用，只有数据节点会存储数据。而在Redis集群中，所有节点都是数据节点，也都参与集群的状态维护。
    
    在Redis集群中，数据节点提供两个TCP端口，在配置防火墙时需要同时开启下面两类端口：    
        普通端口：即客户端访问端口，如默认的6379；
        集群端口：普通端口号加10000，如6379的集群端口为16379，用于集群节点之间的通讯；

    集群的节点之间通讯采用Gossip协议，节点根据固定频率(每秒10次)定时任务进行判断，当集群状态发生变化，如增删节点、槽状态变更时，会通过节点间通讯同步集群状态，使集群收敛。
    
    集群间发送的Gossip消息有下面五种消息类型：    
        MEET：在节点握手阶段，对新加入的节点发送meet消息，请求新节点加入当前集群，新节点收到消息会回复PONG消息；
        PING：节点之间互相发送ping消息，收到消息的会回复pong消息。ping消息内容包含本节点和其他节点的状态信息，以此达到状态同步；
        PONG：pong消息包含自身的状态数据，在接收到ping或meet消息时会回复pong消息，也会主动向集群广播pong消息；
        FAIL：当一个主节点判断另一个主节点进入fail状态时，会向集群广播这个消息，接收到的节点会保存该消息并对该fail节点做状态判断；
        PUBLISH：当节点收到publish命令时，会先执行命令，然后向集群广播publish消息，接收到消息的节点也会执行publish命令；

#### 集群限制

    由于Redis集群中数据分布在不同的节点上，因此有些功能会受限：    
    db库：单机的Redis默认有16个db数据库，但在集群模式下只有一个db0；    
    复制结构：上面的复制结构有树状结构，但在集群模式下只允许单层复制结构；    
    事务/lua脚本：仅允许操作的key在同一个节点上才可以在集群下使用事务或lua脚本；(使用Hash Tag可以解决)    
    key的批量操作：如mget,mset操作，只有当操作的key都在同一个节点上才可以执行；(使用Hash Tag可以解决)    
    keys/flushall：只会在该节点之上进行操作，不会对集群的其他节点进行操作；

#### 集群参数优化

    cluster_node_timeout：默认值为15s。
    
    影响ping消息接收节点的选择，值越大对延迟容忍度越高，选择的接收节点就越少，可以降低带宽，但会影响收敛速度。应该根据带宽情况和实际要求具体调整。
    
    影响故障转移的判定，值越大越不容易误判，但完成转移所消耗的时间就越长。应根据网络情况和实际要求具体调整。
    
    cluster-require-full-coverage
    
    为了保证集群的完整性，只有当16384个槽slot全部分配完毕，集群才可以上线，但同时，若主节点发生故障且故障转移还未完成时，原主节点的槽不在任何节点中，集群会处于下线状态，影响客户端的使用。
    
    该参数可以改变此设定：        
        no:  表示当槽没有完全分配时，集群仍然可以上线；
        yes: 默认配置，只有槽完全分配，集群才可以上线。

#### 实现故障转移

    其实与哨兵模式类似，Redis 的每个节点都会定期向其他节点发送 Ping 消息，以此来检测对方是否在线。当一个节点检测到另一个节点下线后，会将其设置为疑似下线。
    如果一个机器中，有半数以上的节点将某个主节点设为疑似下线，则该节点将会被标记为已下线状态，并开始执行故障转移。
    
    通过 raft 算法从下线主节点的从节点中选出新的主节点
    被选中的从节点执行 SLAVEOF no one 命令，成为新的主节点
    新的主节点撤销掉已下线主节点的槽指派，并将这些槽指给自己
    新的主节点向集群中广播自己由从节点变为主节点
    新的主节点开始接受和负责自己处理槽的有关命令请求

#### Cluster模式的优缺点

    优点：    
        无中心架构，数据按照slot分布在多个节点。
        集群中的每个节点都是平等的关系，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。
        可线性扩展到1000多个节点，节点可动态添加或删除
        能够实现自动故障转移，节点之间通过gossip协议交换状态信息，用投票机制完成slave到master的角色转换
    缺点：    
        客户端实现复杂，驱动要求实现Smart Client，缓存slots mapping信息并及时更新，提高了开发难度。目前仅JedisCluster相对成熟，异常处理还不完善，比如常见的“max redirect exception”
        节点会因为某些原因发生阻塞（阻塞时间大于 cluster-node-timeout）被判断下线，这种failover是没有必要的
        数据通过异步复制，不保证数据的强一致性
        slave充当“冷备”，不能缓解读压力
        批量操作限制，目前只支持具有相同slot值的key执行批量操作，对mset、mget、sunion等操作支持不友好
        key事务操作支持有线，只支持多key在同一节点的事务操作，多key分布不同节点时无法使用事务功能
        不支持多数据库空间，单机redis可以支持16个db，集群模式下只能使用一个，即db 0 Redis Cluster模式不建议使用pipeline和multi-keys操作，减少max redirect产生的场景。

## 参考

- <a href="https://cloud.tencent.com/developer/article/1666804" target="_blank">Redis6.0主从、哨兵、集群搭建和原理</a>

- <a href="https://www.51cto.com/article/647203.html" target="_blank">Redis 三种集群模式</a>

- <a href="https://www.cnblogs.com/hzb462606/p/11121281.html" target="_blank">Redis集群配置和常见异常解决</a>

- <a href="https://zhuanlan.zhihu.com/p/391762630" target="_blank">Redis集群的原理和搭建</a>

- <a href="https://zhuanlan.zhihu.com/p/129640817" target="_blank">Redis有哪几种集群方案？原理和优缺点是什么</a>

- <a href="https://www.cnblogs.com/detectiveHLH/p/14154665.html" target="_blank">深度图解Redis Cluster原理</a>

- <a href="https://cloud.tencent.com/developer/article/1444057" target="_blank">Redis 集群模式的工作原理</a>

- <a href="https://blog.csdn.net/a745233700/article/details/112691126" target="_blank">Redis集群原理详解</a>