<p>
    <a href="#" onclick="refreshContent('redis')">返回目录</a>
</p>

---

# redis 问题收集

1、Redis 与其他 key - value 缓存产品有以下三个特点：

    Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。
    Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
    Redis支持数据的备份，即master-slave模式的数据备份。

2、Redis 分区

        分区是分割数据到多个Redis实例的处理过程，因此每个实例只保存key的一个子集。
    分区的优势
        1、通过利用多台计算机内存的和值，允许我们构造更大的数据库。
        2、通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。
    分区的不足
        1、redis的一些特性在分区方面表现的不是很好：
        2、涉及多个key的操作通常是不被支持的。举例来说，当两个set映射到不同的redis实例上时，你就不能对这两个set执行交集操作。
        3、涉及多个key的redis事务不能使用。
        4、当使用分区时，数据处理较为复杂，比如你需要处理多个rdb/aof文件，并且从多个实例和主机备份持久化文件。
        5、增加或删除容量也比较复杂。redis集群大多数支持在运行时增加、删除节点的透明数据平衡的能力，但是类似于客户端分区、
            代理等其他系统则不支持这项特性。然而，一种叫做presharding的技术对此是有帮助的。

3、redis？ 全称（Remote Dictionary Server）

            Redis是一个内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件
            Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存

4、Redis如何做内存优化？

            尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。
            比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面

5、使用redis有哪些好处

            (1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
            (2) 支持丰富数据类型，支持string，list，set，sorted set，hash
            (3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行
            (4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除

6、怎么理解Redis事务？

            事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
            事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。    

7、Redis事务相关的命令有哪几个？

            MULTI、EXEC、DISCARD、WATCH    
            1.MULTI用来组装一个事务；
            2.EXEC用来执行一个事务；
            3.DISCARD用来取消一个事务；
            4.WATCH用来监视一些key，一旦这些key在事务执行之前被改变，则取消事务的执行。

8、Redis key的过期时间和永久有效分别怎么设置？

            EXPIRE 和 PERSIST 命令

9、Redis特点：

            Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
            
            Redis不仅仅支持简单的key-value类型的数据，同时还提供String，list，set，zset，hash等数据结构的存储。
            
            Redis支持数据的备份，即master-slave模式的数据备份。

10、缓存雪崩

            如果我们的缓存挂掉了，这意味着我们的全部请求都跑去数据库了
            我们都知道Redis不可能把所有的数据都缓存起来(内存昂贵且有限)，所以Redis需要对数据设置过期时间，并采用的是惰性删除+定期删除两种策略对过期键删除。
            如果缓存数据设置的过期时间是相同的，并且Redis恰好将这部分数据全部删光了。这就会导致在这段时间内，这些缓存同时失效，全部请求到数据库中。
            这就是缓存雪崩：Redis挂掉了，请求全部走数据库。
            
            换句话说：大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。
        
            缓存雪崩如果发生了，很可能就把我们的数据库搞垮，导致整个服务瘫痪！

11、如何解决缓存雪崩？

            解决方案：
            （1）在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。
            （2）如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。
            （3）设置热点数据永远不过期。
            （4）使用互斥锁，但是该方案吞吐量明显下降了。
            （5）双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点：
                        从缓存A读数据，有则直接返回
                        A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。
                        更新线程同时更新缓存A和缓存B。
            （6）对于“Redis挂掉了，请求全部走数据库”这种情况，我们可以有以下的思路：
                事发前：实现Redis的高可用(主从架构+Sentinel 或者Redis Cluster)，尽量避免Redis挂掉这种情况发生。
                事发中：万一Redis真的挂了，我们可以设置本地缓存(ehcache)+限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)
                事发后：redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。

12、缓存穿透（缓存中无，DB中也无）

            缓存穿透是指查询一个一定不存在的数据。由于缓存不命中，并且出于容错考虑，如果从数据库查不到数据则不写入缓存，
            这将导致这个不存在的数据每次请求都要到数据库去查询，失去了缓存的意义。
            换一种说法是 ：访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉
            这就是缓存穿透：
            
            请求的数据在缓存大量不命中，导致请求走数据库。
            缓存穿透如果发生了，也可能把我们的数据库搞垮，导致整个服务瘫痪！

13、如何解决缓存穿透？

            解决缓存穿透也有方案：
        
                1、由于请求的参数是不合法的(每次都请求不存在的参数)，于是我们可以使用布隆过滤器(BloomFilter)或者压缩filter提前拦截，不合法就不让这个请求到数据库层！
                2、当我们从数据库找不到的时候，我们也将这个空对象设置到缓存里边去。下次再请求的时候，就可以从缓存里边获取了。这种情况我们一般会将空对象设置一个较短的过期时间。
                3、利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试
                4、采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热（项目启动前，先加载缓存）操作

14、缓存预热：

            系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！
            用户直接查询事先被预热的缓存数据！

15、缓存更新：

            除了redis自带的6种策略(参考本文的第8条)，可以根据业务需求自定义清除缓存。

16、缓存降级：

            当访问量剧增、服务出现问题(如响应时间慢或不响应)或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。
            系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级

17、缓存击穿（缓存中无，但是DB中有）

            一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。
            解决方案
            （1）设置热点数据永远不过期。
            （2）加互斥锁。

18、缓存与数据库双写一致

            对于读操作，流程是这样的
            如果我们的数据在缓存里边有，那么就直接取缓存的。
        
            如果缓存里没有我们想要的数据，我们会先去查询数据库，然后将数据库查出来的数据写到缓存中。
            最后将数据返回给请求。
            
            什么是缓存与数据库双写一致问题？
            
            如果仅仅查询的话，缓存的数据和数据库的数据是没问题的。
            但是，当我们要更新时候呢？各种情况很可能就造成数据库和缓存的数据不一致了。
            这里不一致指的是：数据库的数据跟缓存的数据不一致

19、如何解决缓存和数据库不一致问题

            从理论上说，只要我们设置了键的过期时间，我们就能保证缓存和数据库的数据最终是一致的。因为只要缓存数据过期了，就会被删除。
            随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据写入到缓存中。
        
            除了设置过期时间，我们还需要做更多的措施来尽量避免数据库与缓存处于不一致的情况发生

20、redis的过期策略都有哪些？

        定期删除
                redis默认每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。
                
                假设redis里放了10万个key，都设置了过期时间，你每隔几百毫秒，就检查10万个key，
                那redis基本上就死了，cpu负载会很高的，消耗在你的检查过期key上了。
                
                注意这里可不是每隔100ms就遍历所有的设置过期时间的key，那样就是一场性能上的灾难。
                实际上redis是每隔100ms随机抽取一些key来检查和删除的。
            
        惰性删除
                惰性删除了就是说在你获取某个key的时候，redis会检查一下 ，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。
            
                一般是配合定期删除和惰性删除一起使用

21、Redis常见的回收策略

            volatile-lru：从已设置过期时间的数据集(server.db[i].expires)中挑选最近最少使用的数据淘汰。
            volatile-ttl：从已设置过期时间的数据集(server.db[i].expires)中挑选将要过期的数据淘汰。
            volatile-random：从已设置过期时间的数据集(server.db[i].expires)中任意选择数据淘汰。
            allkeys-lru：从数据集(server.db[i].dict)中挑选最近最少使用的数据淘汰。
            allkeys-random：从数据集(server.db[i].dict)中任意选择数据淘汰。
            no-enviction(驱逐)：禁止驱逐数据

<a href="https://zhuanlan.zhihu.com/p/93515595" target="_blank">吐血整理60个Redis面试题,全网最全</a>

22、Reids三种不同删除策略

            定时删除：
                在设置键的过期时间的同时，创建一个定时任务，当键达到过期时间时，立即执行对键的删除操作

                **优点：**对内存友好，定时删除策略可以保证过期键会尽可能快地被删除，并释放国期间所占用的内存
                **缺点：**对cpu时间不友好，在过期键比较多时，删除任务会占用很大一部分cpu时间，在内存不紧张但cpu时间紧张的情况下，将cpu时间用在删除和当前任务无关的过期键上，影响服务器的响应时间和吞吐量
            
            惰性删除：
                放任键过期不管，但在每次从键空间获取键时，都检查取得的键是否过期，如果过期的话，就删除该键，如果没有过期，就返回该键
                
                **优点：**对cpu时间友好，在每次从键空间获取键时进行过期键检查并是否删除，删除目标也仅限当前处理的键，这个策略不会在其他无关的删除任务上花费任何cpu时间。
                **缺点：**对内存不友好，过期键过期也可能不会被删除，导致所占的内存也不会释放。甚至可能会出现内存泄露的现象，当存在很多过期键，而这些过期键又没有被访问到，这会可能导致它们会一直保存在内存中，造成内存泄露。

            定期删除：
                每隔一点时间，程序就对数据库进行一次检查，删除里面的过期键，至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。
        
                **缺点：**由于定时删除会占用太多cpu时间，影响服务器的响应时间和吞吐量以及惰性删除浪费太多内存，有内存泄露的危险，所以出现一种整合和折中这两种策略的定期删除策略。
                **优点：**定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。
                **优点：**定时删除策略有效地减少了因为过期键带来的内存浪费。

23、内存淘汰机制都有哪些？

            no-eviction：当内存不足以容纳新写入数据时，新写入操作会报错。
            allkeys-lru：当内存不足以容纳新写入数据时，在所有键空间中，移除最近最少使用的key（这个是最常用的）
            allkeys-random：当内存不足以容纳新写入数据时，在所有键空间中，随机移除某个key。
            volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）
            volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key
            volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除

24、持久化机制

            - a). RDB持久化
            
                工作方式 ：根据时间的间隔将redis中数据快照（dump）到dump.rdb文件
                    
                优势 ：备份恢复简单。RDB通过子进程完成持久化工作，相对比AOF启动效率高 
                    RDB文件紧凑，体积小，网络传输快，适合全量复制；恢复速度比AOF快很多。当然，与AOF相比，RDB最重要的优点之一是对性能的影响相对较小。
                
                劣势 ：服务器故障会丢失几分钟内的数据
                    RDB文件的致命缺点在于其数据快照的持久化方式决定了必然做不到实时持久化，而在数据越来越重要的今天，数据的大量丢失很多时候是无法接受的，因此AOF持久化成为主流。
                    此外，RDB文件需要满足特定格式，兼容性差
            
            - b). AOF持久化
            
                工作方式 ：以日志的形式记录所有更新操作到AOF日志文件，在redis服务重新启动时会读取该日志文 件来重新构建数据库，以保证启动后数据完整性。
            
                优势 ：AOF提供两种同步机制，一个是fsync always每次有数据变化就同步到日志文件和fsync everysec每秒同步一次到日志文件，最大限度保证数据完整性。
                    与RDB持久化相对应，AOF的优点在于支持秒级持久化、兼容性好
                
                劣势：日志文件相对RDB快照文件要大的多
                    是文件大、恢复速度慢、对性能影响大
            
            - c). 同时应用AOF和RDB
            
                对于数据安全性高的场景，可同时使用AOF和RDB，这样会降低性能。
            
            RDB，简而言之，就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；
            AOF，则是换了一个角度来实现持久化，那就是将redis执行过的所有写指令记录下来，在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。
            其实RDB和AOF两种方式也可以同时使用，在这种情况下，如果redis重启的话，则会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高。
            如果你没有数据持久化的需求，也完全可以关闭RDB和AOF方式，这样的话，redis将变成一个纯内存数据库，就像memcache一样。

25、持久化策略选择

            （1）如果Redis中的数据完全丢弃也没有关系（如Redis完全用作DB层数据的cache），那么无论是单机，还是主从架构，都可以不进行任何持久化。
            
            （2）在单机环境下（对于个人开发者，这种情况可能比较常见），如果可以接受十几分钟或更多的数据丢失，选择RDB对Redis的性能更加有利；
            如果只能接受秒级别的数据丢失，应该选择AOF。
            
            （3）但在多数情况下，我们都会配置主从环境，slave的存在既可以实现数据的热备，也可以进行读写分离分担Redis读请求，以及在master宕掉后继续提供服务。

26、为什么需要持久化？

            由于Redis是一种内存型数据库，即服务器在运行时，系统为其分配了一部分内存存储数据，一旦服务器挂了，或者突然宕机了，那么数据库里面的数据将会丢失，
            为了使服务器即使突然关机也能保存数据，必须通过持久化的方式将数据从内存保存到磁盘中。

27、Redis cluster集群什么时候不可用

            任意master挂掉且该master没有slave节点，集群将进入fail状态。
            如果master有slave节点，但是有半数以上master挂掉，集群也将进入fail状态。
            当集群fail时，所有对集群的操作都不可用，会出现clusterdown the cluster is down的错误

28、Redis cluster部署条件

            至少要有三个主节点才能构成集群

29、Redis集群最大节点个数是多少？

             16384个

30、Redis集群 模式

            主从复制
                Redis的主从复制解决了数据的备份，以及读写分离。在主服务器出现损坏的时候从服务器依然可以保证数据的安全
            哨兵模式
                哨兵模式：哨兵模式保证的是服务整体的可用性，保证在主服务宕机的时候，及时在从服务中选择一个新的主服务继续提供服务
            Redis集群
                上面解决了服务的可用性，数据的安全性，而Redis集群解决的就是高并发问题。Redis集群将数据进行分散。整个Redis分成不同的数据槽，共同分担数据处理任务。

31、 Redis有哪些数据结构？（面试时）

            字符串String、字典Hash、列表List、集合Set、有序集合SortedSet。
            如果你是Redis中高级用户，还需要加上下面几种数据结构HyperLogLog、Geo、Pub/Sub。
            如果你说还玩过Redis Module，像BloomFilter，RedisSearch，Redis-ML，面试官得眼睛就开始发亮了。

32、Reids常用5种数据类型

            string，list，set，sorted set，hash

| 数据类型 | 概念| 常用命令| 其他|
| --------|--------|--------|--------|
|String(字符串) |key-value型 |get、set、incr、decr、mget||
|Hash(哈希)|field-value,特别适用于存储对象类型（ 对象名-对象属性值）| hget,hset,HMSET,HEGTALL||
|List(列表)|  string类型的有序列表， 按照插入顺序排序|lpush、rpush、lpop、rpop lrange||
|Set(集合)| string类型的无序集合| sadd,spop,smembers,sunion ||
|zset(sorted set：有序集合)|string类型元素的集合,且不允许重复的成员。 每个元素关联一个 ;double值来进行排序， double值可以重复但元素不能重复。| zadd,zrange,zrem,zcard||

33、使用过Redis分布式锁么，它是什么回事？（面试时）

            先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。
            这时候对方会告诉你说你回答得不错，然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？
            这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，
            然后回答：我记得set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！对方这时会显露笑容，心里开始默念：嗯，这小子还不错。

34、Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？（面试时）

            使用keys指令可以扫出指定模式的key列表。
            对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？
            这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。
            这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，
            但是整体所花费的时间会比直接用keys指令长。

35、使用过Redis做异步队列么，你是怎么用的？（面试时）

            一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。
            如果对方追问可不可以不用sleep呢？list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。
            如果对方追问能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。
            如果对方追问pub/sub有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。
            如果对方追问redis如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。
                但是你很克制，然后神态自若的回答道：使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，
                消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。

36、如果有大量的key需要设置同一时间过期，一般需要注意什么？（面试时）

            如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。
            一般需要在时间上加一个随机值，使得过期时间分散一些。

37、Redis如何做持久化的？（面试时）

            bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。
            在redis实例重启时，优先使用aof来恢复内存的状态，如果没有aof日志，就会使用rdb文件来恢复。
            如果再问aof文件过大恢复时间过长怎么办？你告诉面试官，Redis会定期做aof重写，压缩aof文件日志大小。
            如果面试官不够满意，再拿出杀手锏答案，Redis4.0之后有了混合持久化的功能，将bgsave的全量和aof的增量做了融合处理，这样既保证了恢复的效率又兼顾了数据的安全性。
            
            这个功能甚至很多面试官都不知道，他们肯定会对你刮目相看。
            如果对方追问那如果突然机器掉电会怎样？取决于aof日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。
            但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。

38、Pipeline有什么好处，为什么要用pipeline？（面试时）

            可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。
            使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。

39、Redis的同步机制了解么？（面试时）

            从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，
            复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。

40、是否使用过Redis集群，集群的原理是什么？（面试时）

            Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。
            Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储

41、Redis是单线程

            redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销

42、Redis相比memcached有哪些优势：

            memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型
            redis的速度比memcached快很多
            redis可以持久化其数据

43、Redis的并发竞争问题如何解决?

            单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，利用setnx实现锁。

44、Redis是单线程的，但Redis为什么这么快？

            1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；
            2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；
            3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，
                没有因为可能出现死锁而导致的性能消耗；
            4、使用多路I/O复用模型，非阻塞IO；这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程
            5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，
                因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

45、Redis主要消耗什么物理资源？

            内存。

46、一个字符串类型的值能存储最大容量是多少？

            512M   

47、Cluster 集群能支持的数据量有多大？

<a href="https://segmentfault.com/a/1190000039995230" target="_blank">集群能支持的数据量有多大</a>

48、redis数据量过大怎么办

            解决办法当然就是极力减少内存的使用了，一般情况下，我们都是这么做的：
            
                1 设置过期时间        
                    对具有时效性的key设置过期时间，通过redis自身的过期key清理策略来降低过期key对于内存的占用，同时也能够减少业务的麻烦，不需要定期清理了
                
                2 不存放垃圾到redis中        
                    这简直就是废话，但是，有跟我们同病相怜的人么?
                
                3 及时清理无用数据        
                    例如一个redis承载了3个业务的数据，一段时间后有2个业务下线了，那你就把这两个业务的相关数据清理了呗
                
                4 尽量对数据进行压缩        
                    例如一些长文本形式的数据，压缩能够大幅度降低内存占用
                
                5 关注内存增长并定位大容量key        
                    不管是DBA还是开发人员，你用redis，你就必须关注内存，否则，你其实就是不称职的，这里可以分析redis实例中哪些key比较大从而帮助业务快速定位异常key(非预期增长的key，往往是问题之源)
                
                6 pika        
                    如果实在不想搞的那么累，那就把业务迁移到新开源的pika上面，这样就不用太关注内存了，redis内存太大引发的问题，那也都不是问题了。

49、Redis大key多key拆分方案

                业务场景中经常会有各种大key多key的情况， 比如：
                
                1： 单个简单的key存储的value很大
                2： hash， set，zset，list 中存储过多的元素（以万为单位）
                3：一个集群存储了上亿的key，Key 本身过多也带来了更多的空间占用
            
                由于redis是单线程运行的，如果一次操作的value很大会对整个redis的响应时间造成负面影响，所以，业务上能拆则拆，下面举几个典型的分拆方案。
            
                1：单个简单的key存储的value很大
                
                    i： 该对象需要每次都整存整取        
                        可以尝试将对象分拆成几个key-value， 使用multiGet获取值，这样分拆的意义在于分拆单次操作的压力，将操作压力平摊到多个redis实例中，降低对单个redis的IO影响；
                    
                    ii： 该对象每次只需要存取部分数据        
                        可以像第一种做法一样，分拆成几个key-value，  也可以将这个存储在一个hash中，每个field代表一个具体的属性，        
                        使用hget,hmget来获取部分的value，使用hset，hmset来更新部分属性
                
                2：value中存储过多的元素
                
                    类似于场景一种的第一个做法，可以将这些元素分拆。        
                    以hash为例，原先的正常存取流程是  hget(hashKey, field) ; hset(hashKey, field, value)        
                    现在，固定一个桶的数量，比如 10000， 每次存取的时候，先在本地计算field的hash值，模除 10000， 确定了该field落在哪个key上。
                    
                    newHashKey  =  hashKey + ( set, zset, list 也可以类似上述做法但有些不适合的场景，比如，要保证 lpop 的数据的确是最早push到list中去的，这个就需要一些附加的属性，或者是在 key的拼接上做一些工作（比如list按照时间来分拆）。
               
                3：一个集群存储了上亿的key    
                    如果key的个数过多会带来更多的内存空间占用，
                    
                          i：key本身的占用（每个key 都会有一个Category前缀）
                    
                          ii：集群模式中，服务端需要建立一些slot2key的映射关系，这其中的指针占用在key多的情况下也是浪费巨大空间
                    
                          这两个方面在key个数上亿的时候消耗内存十分明显（Redis 3.2及以下版本均存在这个问题，4.0有优化）；
                    
                    所以减少key的个数可以减少内存消耗，可以参考的方案是转Hash结构存储，即原先是直接使用Redis String 的结构存储，现在将多个key存储在一个Hash结构中，

参考：

- <a href="https://cloud.tencent.com/developer/article/1454332" target="_blank">大key多key拆分方案</a>

50、Redis最大的单个value的最大限制是

            1GB 

51、为什么Redis是单线程的？

            Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。
            既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。

52、Redis和Redisson有什么关系？

            Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 

53、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？

            redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。    

其他的面试题：

- <a href="https://zhuanlan.zhihu.com/p/93515595" target="_blank">https://zhuanlan.zhihu.com/p/93515595 </a>

54、redis 是什么？都有哪些使用场景？

            Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。
        
            Redis 使用场景：会话缓存  全页缓存 队列 排行榜/计数器 发布/订阅
                数据高并发的读写
                海量数据的读写
                对扩展性要求高的数据

55.redis 有哪些功能？

            数据缓存功能
        
            分布式锁的功能
        
            支持数据持久化
        
            支持事务
        
            支持消息队列

56、redis 和 memecache 有什么区别？

            memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型
        
            redis的速度比memcached快很多
        
            redis可以持久化其数据

57、redis 为什么是单线程的？

            因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。
        
            关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。
        
             而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。

58、什么是缓存穿透？怎么解决？

            缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。
        
            解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。

59、redis 支持的数据类型有哪些？

            string、list、hash、set、zset。

60、redis 支持的 java 客户端都有哪些？

            Redisson、Jedis、lettuce等等，官方推荐使用Redisson。

61、jedis 和 redisson 有哪些区别？

            Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持。
        
            Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。

62、怎么保证缓存和数据库数据的一致性？

            合理设置缓存的过期时间。
        
            新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。

63、redis 持久化有几种方式？

            Redis 的持久化有两种方式，或者说有两种策略：
        
            RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。
        
            AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。

64、redis 怎么实现分布式锁？

            Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。
        
             占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。

65、redis 分布式锁有什么缺陷？

            Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。

66、redis 如何做内存优化？

            尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。
        
            比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。

67、redis 淘汰策略有哪些？

            volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。
        
            volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。
        
            volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。
        
            allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。
        
            allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。
        
            no-enviction（驱逐）：禁止驱逐数据。

68、redis 常见的性能问题有哪些？该如何解决？

            主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。
        
            Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。

69、链接时发生异常

            1、Unable to connect to Redis; nested exception is io.lettuce.core.RedisConnectionExcept....
            - [https://www.jianshu.com/p/e7ae4a78995b](https://www.jianshu.com/p/e7ae4a78995b)
            
            2、java.lang.NoClassDefFoundError: javax/xml/bind/DatatypeConverter
        
            故障原因：
            
            JAXB API是java EE 的API，因此在java SE 9.0 中不再包含这个 Jar 包。
            java 9 中引入了模块的概念，默认情况下，Java SE中将不再包含java EE 的Jar包
            而在 java 6/7/8 时关于这个API 都是捆绑在一起的
            
            解决方案一：
            降低JDK 版本到 JDK 8
            
            解决方案二:（亲测可行）
            手动加入这些依赖Jar包
        
            <dependency>
                <groupId>javax.xml.bind</groupId>
                <artifactId>jaxb-api</artifactId>
                <version>2.3.0</version>
            </dependency>
            <dependency>
                <groupId>com.sun.xml.bind</groupId>
                <artifactId>jaxb-impl</artifactId>
                <version>2.3.0</version>
            </dependency>
            <dependency>
                <groupId>com.sun.xml.bind</groupId>
                <artifactId>jaxb-core</artifactId>
                <version>2.3.0</version>
            </dependency>
            <dependency>
                <groupId>javax.activation</groupId>
                <artifactId>activation</artifactId>
                <version>1.1.1</version>
            </dependency>

70、java程序中使用redis缓存数据，在redis客户端查不到

            查询的命令不正确，也可能是数据存储的的格式不对，

71、客户端连接时 报错 redis客户端连接(error) NOAUTH Authentication required

    原因：未使用鉴权     
    处理方法：
        1、./redis-cli -h 127.0.0.1 -p 6379 -a Passw0rd

        2、先输入 ./redis-cli -h 127.0.0.1 -p 6379 
           再使用 auth password 鉴权

72、linux下安装redis与启动,及后台启动redis

- <a href="https://blog.csdn.net/q1035331653/article/details/79077260" target="_blank">https://blog.csdn.net/q1035331653/article/details/79077260 </a>

73、启动redis 时若出现权限问题 就将整个文件的执行权限付给当前用户

    [root@localhost redis]# ./bin/redis-server& ./redis.conf
    [1] 25312
    -bash: ./redis.conf: Permission denied

redis 支持的数据类型 的用法

- <a href="https://www.redis.com.cn/redis-data-types.html">https://www.redis.com.cn/redis-data-types.html</a>
