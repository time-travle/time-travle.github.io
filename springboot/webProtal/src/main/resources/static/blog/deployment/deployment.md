# Deployment 分布式


集群是个物理形态，分布式是个工作方式。

            1.分布式：一个业务分拆多个子业务，部署在不同的服务器上， 
                指将不同的业务分布在不同的地方
                分布式是以缩短单个任务的执行时间来提升效率的
            2.集群：同一个业务，部署在多个服务器上， 
                指的是将几台服务器集中在一起，实现同一业务
                集群则是通过提高单位时间内执行的任务数来提升效率。
                
            分布式中的每一个节点，都可以做集群。而集群并不一定就是分布式的
        

集群拥有以下两个特点：

            1.   可扩展性：
                集群的性能不限制于单一的服务实体，新的服务实体可以动态的添加到集群，从而增强集群的性能。
            2.   高可用性：
                集群当其中一个节点发生故障时，这台节点上面所运行的应用程序将在另一台节点被自动接管，消除单点故障对于增强数据可用性、可达性和可靠性是非常重要的。

集群必须拥有以下两大能力：

            1.     负载均衡：
                负载均衡把任务比较均匀的分布到集群环境下的计算和网络资源，以提高数据吞吐量。
            
            2.     错误恢复：
                如果集群中的某一台服务器由于故障或者维护需要无法使用，资源和应用程序将转移到可用的集群节点上。
                这种由于某个节点的资源不能工作，另一个可用节点中的资源能够透明的接管并继续完成任务的过程，叫做错误恢复


负载平衡最重要的一个应用是利用多台服务器提供单一服务


分布式架构概述及设计
- <a href="https://blog.csdn.net/l6108003/article/details/94835586#" target="_blank">https://blog.csdn.net/l6108003/article/details/94835586 </a>

===================================分布事物===========================

什么是事务

            事务可以看做是一次大的活动，它由不同的小活动组成，这些活动要么全部成功，要么全部失败。


数据库事务的四大特性：ACID

            A（Atomic）：原子性，构成事务的所有操作，要么都执行完成，要么全部不执行，不可能出现部分成功部分失败的情况。
        
            C（Consistency）：一致性，在事务执行前后，数据库的一致性约束没有被破坏。比如：张三向李四转 100 元，转账前和转账后的数据是正确状态这叫一致性，如果出现张三转出 100 元，李四账户没有增加 100 元这就出现了数 据错误，就没有达到一致性。
        
            I（Isolation）：隔离性，数据库中的事务一般都是并发的，隔离性是指并发的两个事务的执行互不干扰，一个事务不能看到其他事务的运行过程的中间状态。通过配置事务隔离级别可以比避免脏读、重复读问题。
        
            D（Durability）：持久性，事务完成之后，该事务对数据的更改会持久到数据库，且不会被回滚


理解CAP

             CAP 是 Consistency、Availability、Partition tolerance 三个单词的缩写，分别表示一致性、可用性、分区容忍性

- <a href="https://www.cnblogs.com/dyzcs/p/13780668.html#" target="_blank">https://www.cnblogs.com/dyzcs/p/13780668.html </a>
- <a href="https://www.cnblogs.com/mayundalao/p/11798502.html#" target="_blank">https://www.cnblogs.com/mayundalao/p/11798502.html </a>  4种结局方案

===================================分布式锁=====================


分布式锁的几种实现方式

    基于数据库实现分布式锁 
        基于数据库表
            要实现分布式锁，最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。
            当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录
          实现有以下几个问题：
            1、这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。
            2、这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。
            3、这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，
                要想再次获得锁就要再次触发获得锁操作。
            4、这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。
          当然，我们也可以有其他方式解决上面的问题。
            数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。
            没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。
            非阻塞的？搞一个while循环，直到insert成功再返回成功。
            非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。
        
        基于数据库排他锁
            除了可以通过增删操作数据表中的记录以外，其实还可以借助数据中自带的锁来实现分布式的锁

            这种方法可以有效的解决上面提到的无法释放锁和阻塞锁的问题。
                阻塞锁？ for update语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。
                锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉。

        总结
            总结一下使用数据库来实现分布式锁的方式，这两种方式都是依赖数据库的一张表，一种是通过表中的记录的存在情况确定当前是否有锁存在，
            另外一种是通过数据库的排他锁来实现分布式锁。
            数据库实现分布式锁的优点
                直接借助数据库，容易理解。
            数据库实现分布式锁的缺点
                会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。
            操作数据库需要一定的开销，性能问题需要考虑。
                使用数据库的行级锁并不一定靠谱，尤其是当我们的锁表并不大的时候。


    基于缓存（redis，memcached，tair）实现分布式锁 
        相比较于基于数据库实现分布式锁的方案来说，基于缓存来实现在性能方面会表现的更好一点。而且很多缓存是可以集群部署的，可以解决单点问题
        总结
            可以使用缓存来代替数据库来实现分布式锁，这个可以提供更好的性能，同时，很多缓存服务都是集群部署的，可以避免单点问题。并且很多缓存服务都提供了可以用来实现分布式锁的方法，比如Tair的put方法，redis的setnx方法等。并且，这些缓存服务也都提供了对数据的过期自动删除的支持，可以直接设置超时时间来控制锁的释放。

            使用缓存实现分布式锁的优点

            性能好，实现起来较为方便。

            使用缓存实现分布式锁的缺点

            通过超时时间来控制锁的失效时间并不是十分的靠谱。
            
    基于Zookeeper实现分布式锁
        基于zookeeper临时有序节点可以实现的分布式锁
        大致思想即为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 
        判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 
        当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。

        看下Zookeeper能不能解决前面提到的问题。

            锁无法释放？使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，
                        一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。

            非阻塞锁？使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，
                        客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。

            不可重入？使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，
                        下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，
                         如果不一样就再创建一个临时的顺序节点，参与排队。

            单点问题？使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。

            可以直接使用zookeeper第三方库Curator客户端，这个客户端中封装了一个可重入的锁服务
        总结
            使用Zookeeper实现分布式锁的优点
            有效的解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题。实现起来较为简单。
            使用Zookeeper实现分布式锁的缺点
            性能上不如使用缓存实现分布式锁。 需要对ZK的原理有所了解。


三种方案的比较

    从理解的难易程度角度（从低到高）
    数据库 > 缓存 > Zookeeper

    从实现的复杂性角度（从低到高）
    Zookeeper >= 缓存 > 数据库

    从性能角度（从高到低）
    缓存 > Zookeeper >= 数据库

    从可靠性角度（从高到低）
    Zookeeper > 缓存 > 数据库













