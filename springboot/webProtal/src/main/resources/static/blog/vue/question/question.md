<a href="#" onclick="refreshContent('vue')">返回</a>

## Vue 常见的问题


1、npm和cnpm的区别：

	npm节点包管理器，用与nodejs中节点插件管理，其中包括插件的安装和卸载以及管理依赖的功能呢
	但是有npm这个命令会比较慢 这个默认服务器不是在我们国内，而使用 cnpm这个就会快些 这个是在国内的一个镜像

2、computed VS methods  https://www.cnblogs.com/goloving/p/8964602.html

	我们可以通过在表达式中调用方法来达到同样的效果，我们可以将同一函数定义为一个方法而不是一个计算属性。
	两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。
	
	计算属性只有在它的相关依赖发生改变时才会重新求值。
	计算属性只有在它的相关依赖发生改变时才会重新求值。
	
	这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 
	计算属性会立即返回之前的计算结果，而不必再次执行函数。（缓存的效果）这也同样意味着下面的计算属性将不再更新，
	因为 Date.now() 不是响应式依赖：

	computed: {
	// 里面的是一些方法供直接调用 为一个属性直接绑定方法
	  now: function () {
		return Date.now()
	  }
	}
    相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。
    我们为什么需要缓存？假设我们有一个性能开销比较大的的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。
	然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！
	如果你不希望有缓存，请用方法来替代。
	
3、computed VS watch

    Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，
	你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。
	
	虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。
	这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。
	当需要在数据变化时执行异步或开销较大的操作时，watch这个方式是最有用的。

4、计算属性禁用箭头函数

    注意，不应该使用箭头函数来定义计算属性函数 (例如 aDouble: () => this.a * 2)。
	理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.a 将是 undefined。

    当然有很多this需要指向vue实例的时候，都需要慎用箭头函数	

5、vue的实现流程

	三要素: 双向绑定、模板解析、渲染

	第一步：解析模板成render函数

		with的引用
		模板中所有的信息都要被render函数包含
		模板中用到的data属性都变成js变量
		v-modle、v-for……变成js
		返回vnode
	第二步： 响应式开始监听

		通过object.defineProperty监听到data中属性的get和set方法
		将data中的属性代理带vm上
	第三步： 首次渲染，显示页面，绑定依赖

		首次渲染使用uodateComponent()函数
		vm.patch（$el, vnode）
		patch将vnode转换成dom，完成首次渲染
	第四步：data变化，触发rerender

		命中set的监听
		set 中执行updateComponent
		uodate重新执行render()
		vdom和preVdom比较
		渲染到dom中


6、var 和let的区别

    let命令只在其所在的代码块中有效，用let 声明的变量只在它所在的代码块有效。
        let 命令不允许在相同作用域内重复声明同一个变量。
        let 限制了变量的作用域， 保证变量不会去影响全局变量，所以尽量将var 改为用let
    var可以做的变量提升 ，即变量可以在声明之前使用，值为undefined
7、const 命令

    const 声明一个只读的常量。一旦声明，常量的值就不能改变。
    const 命令的使用场景： const 一般在需要一个模块的时候用或者定义一些全局常量时用。
8、map遍历方法

    Map 结构原生提供3 个遍历器生成函数和l 个遍历方法。具体使用方法查看示例31 。
    keys（）：返回键名的遍历器。
    values （）：返回键值的遍历器。
    entries（）：返回所有成员的遍历器。
    for Each （）： 遍历Map 的所有成员。		