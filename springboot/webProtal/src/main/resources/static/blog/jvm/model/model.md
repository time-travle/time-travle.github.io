<p>
    <a href="#" onclick="refreshContent('jvm')">返回 </a>
</p>

# JVM 模型介绍 日常积累

---

## JVM 模型

    方法区
        元空间
    
    堆
        新代码
        老代码
        常量池
        字符常量
        运行时常量
        
    本地方法栈
    
    虚拟机栈
        栈帧
        
    程序计数器

![avatar](../blog/jvm/imgs/img.png)


0x01:程序计数器（Program Counter Register）

    程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。
    在虚拟机概念模型里（概念模型，各种虚拟机可能会通过一些更高效的方式实现），
    字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令：分支、跳转、循环、异常处理、线程恢复等基础操作都会依赖这个计数器来完成。
    每个线程都有独立的程序计数器，用来在线程切换后能恢复到正确的执行位置，各条线程之间的计数器互不影响，独立存储。
    所以它是一个“线程私有”的内存区域。此内存区域是唯一一个在JVM规范中没有规定任何OutOfMemoryError情况的区域。



0x02:虚拟机栈（VM Stack）

    JVM栈是线程私有的内存区域。
    它描述的是java方法执行的内存模型，每个方法执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
    每个方法从调用直至完成的过程，都对应着一个栈帧从入栈到出栈的过程。每当一个方法执行完成时，该栈帧就会弹出栈帧的元素作为这个方法的返回值，
    并且清除这个栈帧，Java栈的栈顶的栈帧就是当前正在执行的活动栈，也就是当前正在执行的方法。
    就像是组成动画的一帧一帧的图片，方法的调用过程也是由栈帧切换来产生结果。
    
    局部变量表存放了编译器可知的各种基本数据类型（int、short、byte、char、double、float、long、boolean）、对象引用（reference类型，
        它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一跳字节码指令的地址）。
    
    在JVM规范中，对这个区域规定了两种异常情况：
        如果线程请求的栈深度大于虚拟机允许的深度，将抛出StackOverflowError异常；
        如果虚拟机栈可以动态扩展，在扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。
    


0x03:本地方法栈（ Native Method Stack）

    本地方法栈和虚拟机栈所发挥的作用是很相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。
    Sun HotSpot 直接就把本地方法栈和虚拟机栈合二为一。本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。
    
    栈由操作系统自动分配释放 ，用于存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈。参考如下代码：
        int main() {
            int b;				//栈
            char s[] = "abc"; 	//栈
            char *p2;			//栈
        }
    其中函数中定义的局部变量按照先后定义的顺序依次压入栈中，也就是说相邻变量的地址之间不会存在其它变量。
    栈的内存地址生长方向与堆相反，由高到底，所以后定义的变量地址低于先定义的变量，
    比如上面代码中变量 s 的地址小于变量 b 的地址，p2 地址小于 s 的地址。栈中存储的数据的生命周期随着函数的执行完成而结束


0x04:堆（Heap）

    Heap是OOM故障最主要的发源地，它存储着几乎所有的实例对象，堆由垃圾收集器自动回收，堆区由各子线程共享使用；
    通常情况下，它占用的空间是所有内存区域中最大的，但如果无节制地创建大量对象，也容易消耗完所有的空间；
    堆的内存空间既可以固定大小，也可运行时动态地调整，通过参数-Xms设定初始值、-Xmx设定最大值。

    此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。
    这一点在Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，不是“绝对”的。
    Java堆是垃圾收集器管理的主要区域，按照分代收集算法的划分，堆内存空间可以继续细分为年轻代，老年代。
    年轻代又可以划分为较大的Eden区，两个同等大小的From Survivor,To Survivor区。
    默认的Eden区和Survivor区的大小比例为8:1:1，这个比例可以调节。
    在为新创建的对象分配内存的时候先将对象分配到Eden区和From Survivor区，在立即回收时，会将Eden区和Survivor区还存活的对象复制到To Survivor区中，如果To Survivor区的大小不能容纳存活的对象，会把存活的对象分配到老年区。
    总体来说，新创建的小对象会放在年轻代，年轻代的对象大多在下一次垃圾回收时被回收，老年代存储大的对象和存活时间长的对象。

    
    堆由开发人员分配和释放， 若开发人员不释放，程序结束时由 OS 回收，分配方式类似于链表。

0x05:方法区（Method Area）
    
    方法区是被所有线程共享的内存区域，用来存储已被虚拟机加载的类信息、常量、静态变量、JIT（just in time,即时编译技术）编译后的代码等数据。
    运行时常量池是方法区的一部分，用于存放编译期间生成的各种字面常量和符号引用。

![avatar](../blog/jvm/imgs/img_1.png)

    通过反射获取到的类型、方法名、字段名称、访问修饰符等信息就是从方法区获取到的。
    在使用到CGLib对类进行增强时，增强的类越多，就需要越大的方法区类存储动态生成的Class信息，当存放方法区数据的内存溢出时，
    会报OutOfMemoryError异常。在jdk1.8中也就是Metaspace内存溢出，可以通过参数JVM参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize设置Metaspace的空间大小。
    jdk1.8后方法区（Method Area）被元空间(Metaspace)代替。


##堆与栈区别
    堆是运行时确定内存大小，而栈在编译时即可确定内存大小
    堆内存由用户管理(Java中由JVM管理)，栈内存会被自动释放
    栈实现方式采用数据结构中的栈实现，具有(LIFO)的顺序特点，堆为一块一块的内存
    栈由于其实现方式，在分配速度上比堆快的多。分配一块栈内存不过是简单的移动一个指针
    在JVM中，栈不会被程序员直接使用，程序员操作的一般都是堆。
    栈为线程私有而堆为线程共享

堆与栈实际上是操作系统对进程占用的内存空间的两种管理方式，主要有如下几种区别：

    （1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；
    
    （2）空间大小不同。每个进程拥有的栈大小要远远小于堆大小。理论上，进程可申请的堆大小为虚拟内存大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；
    
    （3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。
    
    （4）分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有 2 种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。
        动态分配由alloca()函数分配，但是栈的动态分配和堆是不同的，它的动态分配是由操作系统进行释放，无需我们手工实现。
    
    （5）分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。
                    堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。
    
    （6）存放内容不同。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存，需要使用栈来实现，
                    首先入栈的是主函数下一条语句的地址，即扩展指针寄存器的内容（EIP），然后是当前栈帧的底部地址，即扩展基址指针寄存器内容（EBP），再然后是被调函数的实参等，
                    一般情况下是按照从右向左的顺序入栈，之后是被调函数的局部变量，注意静态变量是存放在数据段或者BSS段，是不入栈的。出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。
                    堆，一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。
    
    从以上可以看到，堆和栈相比，由于大量malloc()/free()或new/delete的使用，容易造成大量的内存碎片，并且可能引发用户态和核心态的切换，效率较低。
    栈相比于堆，在程序中应用较为广泛，最常见的是函数的调用过程由栈来实现，函数返回地址、EBP、实参和局部变量都采用栈的方式存放。虽然栈有众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，主要还是用堆。
    
    无论是堆还是栈，在内存使用时都要防止非法越界，越界导致的非法内存访问可能会摧毁程序的堆、栈数据，轻则导致程序运行处于不确定状态，获取不到预期结果，重则导致程序异常崩溃，这些都是我们编程时与内存打交道时应该注意的问题

数据结构角度
    
    栈就像装数据的细长桶
        栈是一种具有后进先出性质的数据结构，也就是说后存放的先取，先存放的后取。
        这就如同我们要取出放在桶里面底下的东西（放入的比较早的物体），我们首先要移开压在它上面的物体（放入的比较晚的物体）。
    
    堆像一棵倒过来的树
        而堆就不同了，堆是一种经过排序的树形数据结构，每个结点都有一个值。通常我们所说的堆的数据结构，是指二叉堆。
        堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。
        由于堆的这个特性，常用来实现优先队列，堆的存取是随意，

        这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。


##参考：
- <a href="https://zhuanlan.zhihu.com/p/101495810" target="_blank">JVM内存模型（详解） </a>
- <a href="https://www.cnblogs.com/swordfall/p/10723938.html" target="_blank">Java虚拟机—Java8内存模型JVM（整理版）  </a>
