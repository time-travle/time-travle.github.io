<p>
    <a href="#" onclick="refreshContent('multithread')">返回目录</a>
</p>

---

# 高并发 中锁的使用

## Java锁的种类

    乐观锁/悲观锁
    独享锁/共享锁
    互斥锁/读写锁
    可重入锁
    公平锁/非公平锁
    分段锁
    偏向锁/轻量级锁/重量级锁
    自旋锁
    分布式锁

## 轻量级锁

    轻量级锁不是用来替代传统的重量级锁的，而是在没有多线程竞争的情况下，使用轻量级锁能够减少性能消耗，但是当多个线程同时竞争锁时，轻量级锁会膨胀为重量级锁。

## 自旋锁

    在自旋状态下，当一个线程A尝试进入同步代码块，但是当前的锁已经被线程B占有时，线程A不进入阻塞状态，而是不停的空转，等待线程B释放锁。
    如果锁的线程能在很短时间内释放资源，那么等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞状态，只需自旋，等持有锁的线程释放后即可立即获取锁，避免了用户线程和内核的切换消耗。
    
    自旋等待最大时间：线程自旋会消耗cpu，若自旋太久，则会让cpu做太多无用功，因此要设置自旋等待最大时间。
    
    在轻量级锁状态下继续锁竞争，没有抢到锁的线程将自旋，即不停地循环判断锁是否能够被成功获取。
    长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做忙等（busy-waiting）。
    如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁。

优点：

    开启自旋锁后能减少线程的阻塞，在对于锁的竞争不激烈且占用锁时间很短的代码块来说，能提升很大的性能，在这种情况下自旋的消耗小于线程阻塞挂起的消耗。

缺点：

    在线程竞争锁激烈，或持有锁的线程需要长时间执行同步代码块的情况下，使用自旋会使得cpu做的无用功太多。

## 重量级锁

即当有其他线程占用锁时，当前线程会进入阻塞状态

## 偏向锁

    通俗的讲，偏向锁就是在运行过程中，对象的锁偏向某个线程。
    即在开启偏向锁机制的情况下，某个线程获得锁，当该线程下次再想要获得锁时，
    不需要再获得锁（即忽略synchronized关键词），直接就可以执行同步代码，比较适合竞争较少的情况。

    如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。
    线程第二次到达同步代码块时，会判断此时持有锁的线程是否就是自己，如果是则正常往下执行。由于之前没有释放锁，这里也就不需要重新加锁。
    如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。
    
    如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。
    偏向锁通过消除资源无竞争情况下的同步原语，进一步提高了程序的运行性能。一旦有第二个线程加入锁竞争，偏向锁就升级为轻量级锁（自旋锁）。
    升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致STW(stop the word)操作；

### 偏向锁的获取流程：

    （1）查看Mark Word中偏向锁的标识以及锁标志位，若是否偏向锁为1且锁标志位为01，则该锁为可偏向状态。

    （2）若为可偏向状态，则测试Mark Word中的线程ID是否与当前线程相同，若相同，则直接执行同步代码，否则进入下一步。
    
    （3）当前线程通过CAS操作竞争锁，若竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行同步代码，若竞争失败，进入下一步。
    
    （4）当前线程通过CAS竞争锁失败的情况下，说明有竞争。当到达全局安全点时之前获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。

### 偏向锁的释放流程：

    偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁状态的线程才会释放锁，线程不会主动去释放偏向锁。
    偏向锁的撤销需要等待全局安全点（即没有字节码正在执行），它会暂停拥有偏向锁的线程，撤销后偏向锁恢复到未锁定状态或轻量级锁状态。




|锁|优点|缺点|适用场景|
|---|---|---|---|
|偏向锁|加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。|如果线程间存在锁竞争，会带来额外的锁撤销的消耗。|适用于只有一个线程访问同步块场景。|
|轻量级锁|竞争的线程不会阻塞，提高了程序的响应速度。|如果始终得不到锁竞争的线程使用自旋会消耗CPU。|追求响应时间。同步块执行速度非常快。|
|重量级锁|线程竞争不使用自旋，不会消耗CPU。|线程阻塞，响应时间缓慢。|追求吞吐量。同步块执行速度较长。|

- <a href="https://blog.csdn.net/qq_40722827/article/details/105598682" target="_blank">Java锁升级：无锁 → 偏向锁 → 轻量级锁 →
  重量级锁 </a>
- <a href="https://juejin.cn/post/6844903550586191885" target="_blank">浅谈偏向锁、轻量级锁、重量级锁 </a>

 <style>
  table{
    border-left:1px solid #000000;border-top:1px solid #000000;
    width: 100%;
    word-wrap:break-word; word-break:break-all;
  }
  table th{
  text-align:center;
  }
  table th,td{
    border-right:1px solid #000000;border-bottom:1px solid #000000;
  }
</style>

## 什么是乐观锁和悲观锁

    1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，
        因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。

    2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，
        因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。

    
    
    悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。

    悲观锁在Java中的使用，就是利用各种锁。

    乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新

基于MySQL的悲观锁

    因为所有的线程都在访问同一张表，可以在数据库上加锁，典型的做法有悲观锁和乐观锁两种。
    
    悲观锁利用了select...for update 语法，例如：
    
    select * from stock where id=#{id} for update;
    注意：使用悲观锁要把业务代码放在事务里。
      
      悲观锁获取数据时对数据行了锁定，其他事务要想获取锁，必须等原事务结束。
      
      使用selec...for update会把数据给锁住，MySQL InnoDB默认Row-Level Lock，所以只有「明确」地指定主键，MySQL 才会执行Row lock (只锁住被选取的数据) ，否则MySQL 将会执行Table Lock (将整个数据表单给锁住)。
      
      使用悲观锁的缺点是，因为要锁表，所以并发性不高，如果并发过高，数据库压力过大，会宕机。

基于MySQL的乐观锁

    乐观锁相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。
    
    乐观锁的实现有两种方法。
    
    使用版本号实现乐观锁
    版本号的实现方式有两种，一个是数据版本机制，一个是时间戳机制。具体如下。
    
    使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 version 字段来实现。
    当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。
    当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。

## 独享锁/共享锁

    独享锁是指该锁一次只能被一个线程所持有。

    共享锁是指该锁可被多个线程所持有。

    对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。

    读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的。

    独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。

    对于Synchronized而言，当然是独享锁。

## 互斥锁/读写锁

    上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。

    互斥锁在Java中的具体实现就是ReentrantLock。

    读写锁在Java中的具体实现就是ReadWriteLock。

## 公平锁/非公平锁

- <a href="https://zhuanlan.zhihu.com/p/115543000" target="_blank">公平锁和非公平锁的区别 </a>
- <a href="https://www.cnblogs.com/heyouxin/p/13037146.html" target="_blank">【并发编程】公平锁与非公平锁的区别 </a>
- <a href="https://juejin.cn/post/6847902222202896392" target="_blank">公平锁与非公平锁的实现原理 </a>

首先从字面意思理解，公平锁自然是遵循FIFO（先进先出）原则的，先到的线程会优先获取资源，后到的会进行排队等待，而非公平锁是不遵循这个原则的。

公平锁：

    多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。

    优点：所有的线程都能得到资源，不会饿死在队列中。
    缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。

非公平锁：

    多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。

    优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。
    缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。

- <a href="hhttps://blog.csdn.net/qq_14876133/article/details/123025034" target="_blank">Java 公平锁 & 非公平锁 论证 </a>

  论证synchronized是非公平锁 论证ReentrantLock(false)是非公平锁 论证ReentrantLock(true)是公平锁

## 可重入锁(也叫做递归锁)

    指的是同一线程外层函数获得锁之后﹐内层递归函数仍然能获取该锁的代码，在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁 。
    也即是说，线程可以进入任何一个它已经拥有的锁所同步着的代码块。
    ReentrantLock/synchronized就是一个典型的可重入锁
    可重入锁最大的作用是避免死锁
    lock() 和unlock() 只要配对就能正常运行

## synchronized 关键字

    synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。

## synchronized关键字最主要的三种使用方式：

    修饰实例方法:、修饰静态方法、修饰代码块。

    对于普通同步方法，锁是当前实例对象。
    对于静态同步方法，锁是当前类的Class对象。
    对于同步代码块，锁是synchronized括号里配置的对象。
    　　当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。

## synchronized在JVM里是怎么实现的？

    　　synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，
    monitorexit 指令则指明同步代码块的结束位置。 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor的持有权。
    当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。
    如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。
    
    (monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 

## synchronized用的锁是存在哪里的？

    synchronized用到的锁是存在Java对象头里的。

## JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗

    JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。

    锁主要存在四种状态，
    依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。
    
    注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。

    关于这几种优化的详细信息可以查看这篇文章：
    https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Multithread/synchronized.md

## synchronized和 Lock 的区别？（重要）

    1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；

    2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；
    而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；

    3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；

    4）通过Lock可以知道有没有成功获取锁（tryLock()方法：如果获取锁成功，则返回true），而synchronized却无法办到。

    5）Lock可以提高多个线程进行读操作的效率。

    　　在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），
    此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。

    参考https://blog.csdn.net/qq_38200548/article/details/82943222     

## synchronized和ReentrantLock（重入锁） 的区别？

    两者都是可重进入锁，就是能够支持一个线程对资源的重复加锁。sychnronized关键字隐式的支持重进入，比如一个sychnronized修饰的递归方法，
    在方法执行时，执行线程在获取了锁之后仍能连续多次地获取该锁。ReentrantLock虽然没能像sychnronized关键字一样隐式的重进入，
    但是在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。
    线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，
    而锁被释放时，计数自减，当计数等于0时表示锁已经成功被释放。

    synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API。
    ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成）
    ReentrantLock 比 synchronized 增加了一些高级功能，主要有3点：
        ①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）

    ReentrantLock提供了一种能够中断等待锁的线程的机制，也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。通过lock.lockInterruptibly()来实现这个机制。
    ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。（公平锁就是先等待的线程先获得锁）

    synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制。
    ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。
    
    用ReentrantLock类结合Condition实例可以实现“选择性通知” 。
        如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，
        而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程    

## volatile关键字

    保证共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。
    把变量声明为volatile，这就指示 JVM每次使用它都到主存中进行读取     

## synchronized 关键字和 volatile 关键字的区别

    volatile关键字是线程同步的轻量级实现，所以volatile性能比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。
    多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞。、
    volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。
    volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证   

## 什么是活锁、饥饿、无锁、死锁？

    死锁、活锁、饥饿是关于多线程是否活跃出现的运行阻塞障碍问题，如果线程出现 了这三种情况，即线程不再活跃，不能再正常地执行下去了。

死锁

    死锁是多线程中最差的一种情况，多个线程相互占用对方的资源的锁，而又相互等 对方释放锁，此时若无外力干预，这些线程则一直处理阻塞的假死状态，形成死锁。

     举个例子，A 同学抢了 B 同学的钢笔，B 同学抢了 A 同学的书，两个人都相互占 用对方的东西，都在让对方先还给自己自己再还，这样一直争执下去等待对方还而 又得不到解决，

    老师知道此事后就让他们相互还给对方，这样在外力的干预下他们 才解决，当然这只是个例子没有老师他们也能很好解决，计算机不像人如果发现这 种情况没有外力干预还是会一直阻塞下去的。

活锁

    活锁这个概念大家应该很少有人听说或理解它的概念，而在多线程中这确实存在。

     活锁恰恰与死锁相反，死锁是大家都拿不到资源都占用着对方的资源，而活锁是拿 到资源却又相互释放不执行。

    当多线程中出现了相互谦让，都主动将资源释放给别 的线程使用，这样这个资源在多个线程之间跳动而又得不到执行，这就是活锁。

饥饿

    我们知道多线程执行中有线程优先级这个东西，优先级高的线程能够插队并优先执 行，这样如果优先级高的线程一直抢占优先级低线程的资源，导致低优先级线程无 法得到执行，这就是饥饿。

    当然还有一种饥饿的情况，一个线程一直占着一个资源 不放而导致其他线程得不到执行，与死锁不同的是饥饿在以后一段时间内还是能够 得到执行的，如那个占用资源的线程结束了并释放了资源。

无锁

    无锁，即没有对资源进行锁定，即所有的线程都能访问并修改同一个资源，但同时 只有一个线程能修改成功。

    无锁典型的特点就是一个修改操作在一个循环内进行， 线程会不断的尝试修改共享资源，如果没有冲突就修改成功并退出否则就会继续下 一次循环尝试。

    所以，如果有多个线程修改同一个值必定会有一个线程能修改成功， 而其他修改失败的线程会不断重试直到修改成功。之前的文章我介绍过 JDK 的 CAS 原理及应用即是无锁的实现。

     可以看出，无锁是一种非常良好的设计，它不会出现线程出现的跳跃性问题，锁使 用不当肯定会出现系统性能问题，虽然无锁无法全面代替有锁，但无锁在某些场合 下是非常高效的。



