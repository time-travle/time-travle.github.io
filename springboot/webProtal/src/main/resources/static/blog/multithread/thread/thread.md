<p>
    <a href="#" onclick="refreshContent('multithread')">返回目录</a>
</p>

---

# 线程的使用

## 0、创建线程的几种方式？（重要）

    有4种方式：继承Thread类、实现Runnable接口、实现Callable接口、使用Executor框架来创建线程池
    
    通过继承Thread类创建线程
    
    通过实现Runnable接口来创建线程
    
    实现Callable接口来创建线程
    　　与实现Runnable接口类似，和Runnable接口不同的是，Callable接口提供了一个call() 方法作为线程执行体，call()方法比run()方法功能要强大：
        call()方法可以有返回值、call()方法可以声明抛出异常。

    使用Executor框架来创建线程池
    　　Executors.newXXXX： newFixedThreadPool(int )、newSingleThreadExecutor、newCachedThreadPool、newScheduledThreadPool(int)
     　　通过Executors的以上四个静态工厂方法获得 ExecutorService实例，而后可以执行Runnable任务或Callable任务。

### 实现Runnable接口和Callable接口的区别？

         Runnable接口或Callable接口实现类都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。两者的区别在于 Runnable 接口不会返回结果但是 Callable 接口可以返回结果。

        执行execute()方法和submit()方法的区别是什么呢？
        1) execute() 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；

        2) submit() 方法用于提交需要返回值的任务。线程池会返回一个Future类型的对象，通过这个Future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值

## 1、创建线程的三种方式的对比？

### 1）采用实现Runnable、Callable接口的方式创建多线程。

优势是：

    线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。

    在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。

劣势是：

    编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。

### 2）使用继承Thread类的方式创建多线程

优势是：

    编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。

劣势是：

    线程类已经继承了Thread类，所以不能再继承其他父类。

### 3）Runnable和Callable的区别

        Callable规定（重写）的方法是call()，Runnable规定（重写）的方法是run()。
        Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。
        Call方法可以抛出异常，run方法不可以。
        运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。


## 2.线程和进程的区别是什么？

    进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地 址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，
    而线程只是一 个进程中的不同执行路径。

    线程有自己的堆栈和局部变量，但线程之间没有单独的 地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，
    但在进程切换时，耗费资源较大，效率要差一些。

    但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

## 3.Java 实现线程有哪几种方式？

    （1）继承 Thread 类实现多线程
    
    （2）实现 Runnable 接口方式实现多线程
    
    （3）使用 ExecutorService、Callable、Future 实现有返回结果的多线程
    
    （4）通过线程池创建线程

## 4.启动线程方法 start()和 run()有什么区别？

    只有调用了 start()方法，才会表现出多线程的特性，不同线程的 run()方法里面的代码交替执行。如果只是调用 run()方法，那么代码还是同步执行的，必须等待一个线程的 run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其 run() 方法里面的代码。

## 5.怎么终止一个线程？如何优雅地终止线程？

    stop 终止，不推荐。

## 6.一个线程的生命周期有哪几种状态？它们之间如何流转的？

    NEW：毫无疑问表示的是刚创建的线程，还没有开始启动。

    RUNNABLE: 表示线程已经触发 start()方式调用，线程正式启动，线程处于运行中 状态。

    BLOCKED：表示线程阻塞，等待获取锁，如碰到 synchronized、lock 等关键字等占用临界区的情况，一旦获取到锁就进行 RUNNABLE 状态继续运行。

    WAITING：表示线程处于无限制等待状态，等待一个特殊的事件来重新唤醒，如 通过wait()方法进行等待的线程等待一个 notify()或者 notifyAll()方法，通过 join()方 法进行等待的线程等待目标线程运行结束而唤醒，一旦通过相关事件唤醒线程，线 程就进入了 RUNNABLE 状态继续运行。

    TIMED_WAITING：表示线程进入了一个有时限的等待，如 sleep(3000)，等待 3 秒 后线程重新进行 RUNNABLE 状态继续运行。

    TERMINATED：表示线程执行完毕后，进行终止状态。需要注意的是，一旦线程通过start 方法启动后就再也不能回到初始 NEW 状态，线程终止后也不能再回到 RUNNABLE 状态 。

## 7.线程中的 wait()和 sleep()方法有什么区别？

    这个问题常问，sleep 方法和 wait 方法都可以用来放弃 CPU 一定的时间，不同点在于如果线程持有某个对象的监视器，sleep 方法不会放弃这个对象的监视器，wait 方法会放弃这个对象的监视器。

## 8.多线程同步有哪几种方法？

    Synchronized 关键字，Lock 锁实现，分布式锁等。

## 9.多线程有什么用？

    1）发挥多核CPU的优势

    随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的 ，4 核、8 核甚至 16 核的也都不少见，如果是单线程的程序，那么在双核 CPU 上 就浪费了 50%， 在 4 核 CPU 上就浪费了 75%。

    单核 CPU 上所谓的"多线程"那是 假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快， 看着像多个线程"同时"运行罢了。

    多核 CPU 上的多线程才是真正的多线程，它能 让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU 的优势来，达到充 分利用CPU 的目的。

    2）防止阻塞

    从程序运行效率的角度来看，单核 CPU 不但不会发挥出多线程的优势，反而会因 为在单核CPU 上运行多线程导致线程上下文的切换，而降低程序整体的效率。

    但 是单核 CPU 我们还是要应用多线程，就是为了防止阻塞。试想，如果单核 CPU 使 用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返 回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。

    多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻 塞，也不会影响其它任务的执行。

    3）便于建模

    这是另外一个没有这么明显的优点了。假设有一个大的任务 A，单线程编程，那么 就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务 A 分解成 几个小任务，任务B、任务 C、任务 D，分别建立程序模型，并通过多线程分别运 行这几个任务，那就简单很多了。

## 10.多线程之间如何进行通信？

    wait/notify

## 11、线程怎样拿到返回结果？

    实现Callable 接口。

## 12、violatile 关键字的作用？

    一个非常重要的问题，是每个学习、应用多线程的 Java 程序员都必须掌握的。理 解 volatile关键字的作用的前提是要理解 Java 内存模型，这里就不讲 Java 内存模型 了，可以参见第31 点，volatile 关键字的作用主要有两个：

    1）多线程主要围绕可见性和原子性两个特性而展开，使用 volatile 关键字修饰的变 量，保证了其在多线程之间的可见性，即每次读取到 volatile 变量，一定是最新的数据。

    2）代码底层执行不像我们看到的高级语言----Java 程序这么简单，它的执行是 Java 代码–>字节码–>根据字节码执行对应的 C/C++代码–>C/C++代码被编译成汇编语 言–>和硬件电路交互，现实中，为了获取更好的性能 JVM 可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。

    使用 volatile 则会对禁止语义重排 序，当然这也一定程度上降低了代码执行效率从实践角度而言，volatile 的一个重 要 作 用 就 是 和 CAS 结 合。

## 13、新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？

    用 join 方法。

## 14、怎么控制同一时间只有 3 个线程运行？

    用 Semaphore。

## 15、ThreadLocal

    ThreadLocal很容易让人望文生义，想当然地认为是一个“本地线程”。其实，ThreadLocal并不是一个Thread，而是Thread的局部变量，
    也许把它命名为ThreadLocalVariable更容易让人理解一些。
    当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，
    而不会影响其它线程所对应的副本。
    从线程的角度看，目标变量就象是线程的本地变量，这也是类名中“Local”所要表达的意思


## 16、线程、进程、协程的区别

    进程：是系统分配资源都基本单元，有独立的内存空间 比如一个迅雷应用程序，既不共享堆，亦不共享栈。一个进程中至少有一个线程。
    线程：线程是操作系统调度的最小单元线程拥有自己独立的栈和共享的堆，共享堆，不共享栈比如为在迅雷程序中开启多个下载任务下载就是多线程。
        如果只有单个线程，那么我们就只能下载一个任务，然后等待他下载完了再下载，而开启多个线程就可以同时下载多个任务。

    协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。而线程是CPU进行调度。

    协程和线程的区别是：协程避免了无意义的调度，由此可以提高性能，但也因此，**程序员必须自己承担调度的责任，**同时，
    协程也失去了标准线程使用多CPU的能力。在线程里面可以开启协程，让程序在特定的时间内运行。也就是说一个线程执行不同的协程。

## 17、Thread.Sleep(0)的作用

    因此，Thread.Sleep(0)的作用，就是“触发操作系统立刻重新进行一次CPU竞争”。给其他线程获得CPU执行一次的机会。
    竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权。这也是我们在大循环里面经常会写一句Thread.Sleep(0) ，
    因为这样就给了其他线程比如Paint线程获得CPU控制权的权力。

## 18、产生死锁之后如何查看

    用JPS定位进程号，
    用jstack查看线程死锁问题
